#! /usr/bin/env python
#
# Support module generated by PAGE version 4.7
# In conjunction with Tcl version 8.6
#    Aug 10, 2016 07:45:39 PM
#    Aug 17, 2016 09:47:48 AM


try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk
    py3 = 0
except ImportError:
    import tkinter.ttk as ttk
    py3 = 1

def set_Tk_var():
    # These are Tk variables used passed to Tkinter and must be
    # defined before the widgets using them are created.
    global minBunnies
    minBunnies = DoubleVar()

    global maxBunnies
    maxBunnies = DoubleVar()
    maxBunnies.set(20000)

    global stepSize
    stepSize = DoubleVar()
    stepSize.set(1000)
    
    global animation
    animation = StringVar()

    global scaled
    scaled = StringVar()

    global random
    random = StringVar()

    global rotated
    rotated = StringVar()

    global multitexture
    multitexture = StringVar()

    global texturechange
    texturechange = StringVar()

    global alpha
    alpha = StringVar()

    global hd
    hd = StringVar()

    global resolution
    resolution = StringVar()
    resolution.set("800x600")
    
    global minBunniesEntry
    minBunniesEntry = StringVar()
    
    global maxBunniesEntry
    maxBunniesEntry = StringVar()
    
    global stepSizeEntry
    stepSizeEntry = StringVar()

    updateEntries()
    
    global presets
    presets = StringVar()

    global presetsCombobox
    presetsCombobox = StringVar()
    presetsCombobox.trace('w', lambda name, idx, mode: cmdTogglePresets())
    
    
def cmdChoose():
    moveSelectionToListbox(w.possibleFrameworksList, w.chosenFrameworksList)
    if w.chosenFrameworksList.get(0) != '':
        w.runButton.configure(state="normal")
    
def cmdUnchoose():
    moveSelectionToListbox(w.chosenFrameworksList, w.possibleFrameworksList)
    if w.chosenFrameworksList.get(0) == '':
        w.runButton.configure(state="disabled")

def moveSelectionToListbox(src, dst):
    selectionIndices = src.curselection()
    selected = [src.get(s) for s in selectionIndices]
    for i in range(len(selectionIndices)):
        src.delete(selectionIndices[i]-i)
    for s in selected:
        dst.insert(END, s)
    
def cmdMaxBunnies(self):
    if maxBunnies.get() < minBunnies.get():
        minBunnies.set(maxBunnies.get())
    updateEntries()

def cmdMinBunnies(self):
    if minBunnies.get() > maxBunnies.get():
        maxBunnies.set(minBunnies.get())
    updateEntries()
        
def cmdStepSize(self):
    stepSizeEntry.set(int(round(stepSize.get())))
    
def cmdTogglePresets():
    comboboxState = "normal" if presets.get() == '1' else "disabled"
    buttonState = comboboxState if not presetsCombobox.get() == '' else "disabled"
    w.presetsCombobox.configure(state=comboboxState)
    w.saveButton.configure(state=buttonState)
 
def cmdSave():
    open("presets.csv", "a").close()
    lines = getLinesFromFile("presets.csv")
    f = open("presets.csv", 'w')
    f.write("# Do not edit this file!\n")
    for l in lines: 
        if not l.split(",")[0] == presetsCombobox.get():
            f.write(l+'\n')
    
    f.write(presetsCombobox.get()
            +','+','.join(map(lambda x: x.get(), testList))
            +','+str(int(minBunnies.get()))
            +','+str(int(maxBunnies.get()))
            +','+str(int(stepSize.get()))
            +','+resolution.get()+'\n')
    f.close()
     
def presetSelection(event):
    # This method gets evaluated each time a preset is selected in the combobox
    # The selected preset is read from file and ui values are set respectively
    lines = getLinesFromFile("presets.csv")
    for l in lines:
        values = l.split(",") 
        if values[0] == presetsCombobox.get():
            numTests = len(testList)
            cvalues = values[1:numTests+1]
            for i in range(numTests):
                testList[i].set(cvalues[i])
            minBunnies.set(values[numTests+1])
            minBunniesEntry.set(values[numTests+1])
            maxBunnies.set(values[numTests+2])
            maxBunniesEntry.set(values[numTests+2])
            stepSize.set(values[numTests+3])
            stepSizeEntry.set(values[numTests+3])
            resolution.set(values[numTests+4])
           
def getLinesFromFile(file):     
    # returns list of the file's lines
    f = open(file, 'r')
    lines = f.read().splitlines()
    f.close()
    return lines[1:]
    
def updatePresets():
    # called each time the presets combobox list is opened
    # reads presets from file and adds them to the combobox
    open("presets.csv", "a").close()
    w.presetsCombobox.configure(values = [l.split(",")[0] for l in getLinesFromFile("presets.csv")])
    
def getTests():
    tests = ''
    for i in range(len(testList)):
        x = testList[i].get()
        tests = tests + ',' + x if (tests != '' and x != '') else x if x != '' else tests
        
    if tests == '':
        tests = 'standard'
    return tests

def updateEntries():
    maxBunniesEntry.set(int(round(maxBunnies.get())))
    minBunniesEntry.set(int(round(minBunnies.get())))
    stepSizeEntry.set(int(round(stepSize.get())))


def validateMinBunnies(newVal, eventType):
    if eventType == "focusout":
        newVal = truncateValue(newVal, 0, bunnyScaleCap)
        minBunnies.set(newVal)
        if int(newVal) > maxBunnies.get():
            maxBunnies.set(newVal)
        updateEntries()
            
    elif eventType == "key":
        try:
            newVal == '' or int(newVal)
            minBunnies.set(newVal)
        except:
            return False
    return True
    
def validateMaxBunnies(newVal, eventType):
    if eventType == "focusout":
        newVal = truncateValue(newVal, 0, bunnyScaleCap)
        maxBunnies.set(newVal)
        if int(newVal) < minBunnies.get(): 
            minBunnies.set(newVal)
        updateEntries()
        
    elif eventType == "key":
        try:
            newVal == '' or int(newVal)
            maxBunnies.set(newVal)
        except:
            return False
    return True
    
def validateStepSize(newVal, eventType):
    if eventType == "focusout":
        value = truncateValue(newVal, 1, stepScaleCap)
        stepSizeEntry.set(value)
        stepSize.set(value)
    elif eventType == "key":
        try:
            newVal == '' or int(newVal)
            stepSize.set(newVal)
        except:
            return False
    return True
    
def truncateValue(value, low, high):
    if value == '' or int(value) < low:
        return low
    if int(value) > high:
        return high    
    return value

def validatePreset(newVal):
    try:
        # Preset names must not contain non ascii characters.
        newVal.decode('ascii')
        return "," not in newVal
    except:
        return False

def cmdRun():
    import testmanager
    chosenFrameworks = list(w.chosenFrameworksList.get(0, END))
    x, y = resolution.get().split("x")
    destroy_window()    
    testmanager.run_test(chosenFrameworks,
                         getTests(), 
                         int(round(minBunnies.get())), 
                         int(round(maxBunnies.get())), 
                         int(round(stepSize.get())),
                         x,
                         y)
    # Restart the UI after test execution 
    import bunnysuite_gui
    bunnysuite_gui.vp_start_gui()

def init(top, gui, *args, **kwargs):
    global w, top_level, root, testList, frameworks, bunnyScaleCap, stepScaleCap
    w = gui
    top_level = top
    root = top
    testList = [animation,scaled,random,rotated,multitexture,texturechange,alpha,hd]
    bunnyScaleCap = 100000
    stepScaleCap = 10000    
    frameworks = getFrameworks()
    for f in frameworks:
        w.chosenFrameworksList.insert(END, f)

def getFrameworks():
    # Searches for subdirectories containing a 'bin' folder containing App.jar/App.exe
    import os
    frameworks = []    
    for directory in next(os.walk('.'))[1]:
        if 'bin' in next(os.walk(directory))[1]:
            for fname in os.listdir(directory+'/bin'):
                if fname == 'App.exe' or fname == 'App.jar':
                    frameworks.append(directory)
                    break
    return frameworks
        
def destroy_window():
    # Function which closes the window.
    global top_level
    # Bugfix for a tk bug where a script cannot cancel itself:
    top_level.eval('::ttk::CancelRepeat')
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    import bunnysuite_gui
    bunnysuite_gui.vp_start_gui()




