\begin{abstract}
TODO
\end{abstract}

\chapter{Einleitung}
Moderne Computerspiele setzen basieren meistens auf der graphischen Darstellung ihrer Spielwelt. Dabei geht vor allem in den letzten Jahren der Trend  verstaerkt in die Richtung photorealistischen 3D-Renderings und weg von der simpleren 2D Darstellung.
Dabei ist schnelles 2D-Rendering immernoch eine nichttriviale Aufgabe für GPUs. Für viele Anwendungen sind die verfügbaren Bibliotheken im Allgemeinen immer noch viel zu langsam. Um das zu verbessern, haben wir mit \textit{BunnySuite} ein Framework entwickelt, mit dem gängige 2D-Grafik-Bibliotheken einem automatisierten Stresstest ausgesetzt werden können.\\
Mit dem \textit{BunnyMark}\footnote{https://github.com/openfl/openfl-samples/tree/master/demos/BunnyMark} gab es bereits eine Metrik zum Vergleich von Bibliotheken. Jedoch wurde hier nur die Anzahl der gerenderten Objekte (in diesem Fall Häschen, deshalb der Name) gemessen, bei denen noch 60 fps erreicht werden. Diese Zahl war nur schwer zu interpretieren und musste für ein ausführlicheres Ranking durch aussagekräftigere Metriken, bspw. \textit{Renderzeit pro Frame bei X Objekten} ersetzt werden. Auch findet diese Messung bei BunnyMark zu Demozwecken nur interaktiv statt: Häschen werden per Mausklick zur Szene hinzugefügt. Im von uns entwickelten BunnySuite-Framework können solche Messungen automatisiert erfolgen. Die Tests für mehrere Frameworks werden automatisch nacheinander gestartet und das Ergebnis wird in einem Diagramm zusammengefasst. Das Framework ist leicht erweiterbar, so dass man es mit wenig Aufwand an neue Bibliotheken anpassen kann.\\
Das vollautomatisierte Test-Framework soll Entscheidern der Spieleentwicklung die Möglichkeit eines Rankings bieten, um die richtige Bibliothek für ihre Anforderungen zu finden. Des Weiteren sollen Entwickler von Bibliotheken das Framework nutzen können, um ihre eigene Engine zu testen und zu optimieren. Die Leistungen der Bibliotheken können so transparent verglichen werden, was den Wettbewerb zwischen den Bibliotheken stimulieren und Anreize setzen soll, stärker an der Performanz zu arbeiten.

\chapter{Zeitplan und Aufgabenverteilung}
Das Team hat sich darauf geeinigt, dass jeder Entwickler sich auf eine Bibliothek konzentriert. In Regelmaessigen Meetings werden Konzepte diskutiert und Designentscheidungen getroffen. Somit soll in allem Frameworks eine vergleichbare Implementierung erreicht werden
\includegraphics[width=1.2\textwidth]{projektplan.pdf}


\chapter{Grundlagen}
\section{2D-Frameworks}
Game Frameworks sollen die Entwickler beim Implementieren der Game Loop unterstützen. Diese Game Loop besteht hauptsaechlich aus 2 Phasen:

\begin{description}

\item[Update()] Der interne Zustand der Spielwelt und ihrer Objekte wird aktualisiert, bspw. die Position der Spielfigur gemaess der Benutzereingaben angepasst oder das naechste Frame in einer Animation wird ausgewaehlt oder die Punktzahl erhoeht. Zeitgleich finden hier auch komplexere Berechnungen statt, wie die Kollisionsbestimmung, die wieder zu neuen Berechnungen fuehren kann (Positionen werden angepasst, damit Objekte sich nicht ueberlagern; "Gesundheitswerte" werden bei Treffern verringert)
\item[Draw()] Die im vorherigen Schritt berechnete Spielwelt wird auf dem Bildschirm dargestellt. Dazu gehoeren die korrekte Position aller Objekte, die Texturierung und Beleuchtung dieser Objekte, und ggf. Transformationen (Skalierung, Rotation). Auch muss bei Ueberlagerung von Objekten auf die korrekte Darstellung geachtet werden. Anschliessend wird noch die Benutzeroberflaeche ueber den Bildschirminhalt gelegt.
\end{description}

Die Game Frameworks unterstuetzen die Entwickler indem sie verschiedene Funktionalitaeten bereits zur Verfuegung stellen. Dazu gehoeren:

\begin{itemize}
\item Einfacher Zugriff auf Eingabegeraete, wie Maus, Tastatur, Gamepad, Joystick, Touch- und Gestensteuerung
\item optimierte Klassen fuer Assets wie Audiodateien oder Texturen inklusive Kompression
\item optimierte Renderfunktionen, die direkt Graphikschnittstellen wie OpenGL, Dirext3D oder Vulkan ansprechen. Diese koennen auch bereits Transformationen wie Drehungen oder Einfaerbungen anbieten.
\end{itemize}

Diese Bibliotheken helfen den Entwicklern eine effiziente Implementierung zu erreichen, ohne sehr hardwarenahe Optimierungen selber programmieren zu muessen. Somit soll sehr einfach der "Goldstandard" von 60 Frames per Second in der Darstellungen erreicht werden, bei dem fuer jeden Schritt der Gameloop eine Rechenzeit von knapp 16,67ms zur Verfuegung steht. Dies beinhaltet das einlesen von Assets wie Texturen vom Speichersystem der jeweiligen Plattform. 

Der wahrscheinlich größte Unterschied zu 3D-Frameworks besteht in der Komplexität der Grafikberechnung. So muss das 2D-Framework meistens keine Informationen über Oberflächen der Objekte, z.B. Orientierung über NormalMaps oder Materialeigenschaften für das \emph{Physically Based Rendering (PBR)}, außer der konkreten Farbe, kennen. 
Auch koennen diese Objekte bereits ihrer Darstellung entsprechend als Sprite vorliegen, die ggf. noch mit Transformationen angepasst, direkt dargestellt werden koennen. Somit muss kein komplexes 3 dimensionales Objekt auf einmal im Speicher gehalten werden, bei dem man sowieso nur die der Kamera zugewandten Seite sieht, sondern bspw. nur ein Spritesheet mit den 4 moeglichen Orientierungen des Objekts.
Ebenso entfaellt bei der Darstellung eine komplexe Berechnung der Ueberlagerung, oder verdeckter Rueckseiten der Objekte. Es wird nur die momentane Orientierung der Objekte dargestellt. Die Verdeckung von Objekten kann durch Layerbasiertes Rendering geloest werden:

\begin{enumerate}
\item Hintergrund rendern
\item Nicht Spieler Objekte rendern
\item Spieler Objekt rendern
\item Benutzeroberflaeche rendern
\end{enumerate}

Diese Besonderheiten vereinfachen die Berechnung im 2D-Darstellungsfall. Dadurch ist dieser Fall aber nicht so gut optimiert, wie die 3D Anwendung, und es werden regelmaessig Grenzen ausgereizt.

\section{Benchmarking}
Um eine moeglichst einfache Bedienung zu gewaehrleisten, soll der Benchmark vollautomatisiert erfolgen. Wichtigste Eigenschaft des Benchmarks ist die Vergleichbarkeit der Ergebnisse. Dazu wurde die Renderzeit pro Frame bei X Objekten als Kennzahl eingeführt. Wie bei allen empirischen Untersuchungen muss diese den folgenden drei Kriterien genügen:\\
\begin{description}
\item[Validität] Dass sich die Kennzahl mit empirischen Messergebnissen deckt, ist garantiert, da sie empirisch zustande kommt. Es wurde die in Entwicklerkreisen übliche Größe {\em Renderzeit pro Frame in Sekunden} gewählt, im Gegensatz zu ihrer Inversen, {\em Frames per Second}, oder einem arbiträren Punktesystem.\\
\item[Objektivität] ist durch die Wohldefiniertheit der einzelnen Testverfahren gegeben (siehe \ref{sec:tests}).\\
\item[Reliabilität] Als Maßnahme für hohe Reliabilität werden alle Messungen jeweils zehn mal durchgeführt und anschließend der Durchschnitt gebildet, um Einflüsse von Hintergrundprozessen zu minimieren. (siehe ..) \\
% Falls es noch eine ausführliche Testreihe zur Reliabilität geben sollte, muss das hier noch eingefügt werden.
\end{description}

\chapter{Konzept und Design}

\section{Allgemeines}
Bei der Konzeption einer Benchmark gibt es grundsätzlich zwei verschiedene Herangehensweisen: Zum einen kann man eine repräsentative, in der Regel sehr komplexe Test-Szene rendern lassen, in der alle möglichen Schwierigkeiten und Bottlenecks vorkommen, die gemeinhin bei der Grafikprogrammierung auftauchen, und damit die GPU an die Grenze der Belastbarkeit zu bringen. Das ist der übliche Ansatz bei im Internet frei verfügbaren Benchmarks\footnote{Ein Beispiel: https://unigine.com/products/benchmarks/heaven/}, die dazu dienen, die Fähigkeiten der eigenen Grafikkarte, also Hardware, zu testen. Zum anderen kann man viele einzelne, feingranulare Tests definieren, die auf einzelne Bottlenecks abzielen. Für das BunnySuite-Framework haben wir diese Herangehensweise gewählt, da das Framework explizit für den Vergleich von Grafik-Libraries konzipiert ist. Der Vorteil von feingranularen Tests ist, dass die Ergebnisse für die Entwickler sehr viel aussagekräftiger sind, weil sie ihnen präzise Hinweise geben, an welchen Stellen das eigene Framework hinter die anderen abfällt und wo eine Optimierung am meisten bringen würde. Außerdem vereinfacht dieser Ansatz die Entwicklung und Implementierung der Tests enorm. Ein Nachteil ist, dass die Tests teilweise artifizielle Anforderungen stellen, die in echten 2D-Spielen nicht vorkommen. Dieser Nachteil wird aber dadurch ausgeglichen, dass man die Tests -- soweit sinnvoll -- frei kombinieren kann. Außerdem ist die spätere Erweiterung des Frameworks um komplexere Tests durchaus möglich.

\section{Identifizierte Bottlenecks}
Da jede 2D-Grafik-Bibliothek ihre eigenen Stärken und Schwächen aufweist und für unterschiedliche Zwecke optimiert ist, ist es wichtig, differenzierte Tests durchzuführen, um gezielt mögliche Schwachstellen zu identifizieren, ohne dabei die Stärken zu ignorieren. Zu diesem Zweck wurden verschiedene "Bottlenecks" identifiziert, also häufige Schwachstellen, für die gezielt Tests entwickelt wurden. Diese sind unter anderem:\\
\begin{itemize}
\item Animieren der Objekte
\item Objekte mit veränderlichen Texturen
\item Vielzahl an gleichzeitig dargestellten Objekten mit unterschiedlichen Texturen
\item Skalierung der Objekte
\item Rotation der Objekte
\item Objekte mit (halb-)transparenten Texturen
\end{itemize}

\chapter{Umsetzung und Tests}

\section{Ablauf der Tests}
Der Ablauf eines Tests im \textit{BunnySuite}-Frameworks ist in Abbildung \ref{dia:architecture} schematisch dargestellt. Das Framework besteht im Wesentlichen aus zwei Teilen:
\begin{enumerate}
\item Das \textbf{Manager-Skript} ist dafür zuständig, den spezifizierten Test für alle Frameworks nacheinander zu starten, anschließend die Logs zu analysieren und die Ergebnisse in einem Diagramm zu visualisieren.
\item Es gibt eine \textbf{ausführbare EXE-Datei} für jedes Framework. Diese Datei wird vom Manager-Skript gestartet und bekommt die Parameter für die Messung als Argumente über die Command-Line übergeben. Das Programm führt die spezifizierten Tests durch und loggt die Renderzeit pro Frame bei X Objekten.
\end{enumerate}
\begin{figure}[h]
\caption{Ablauf eines Tests}
\centering
\includegraphics[width=0.8\textwidth]{Architecture}
\label{dia:architecture}
\end{figure}
~\\
Der auszuführende Test wird durch folgende Parameter spezifiziert:\\
\begin{description}
\item[test\_name] Der Name eines Tests. Die Tests werden in \ref{sec:tests} aufgelistet.
\item[min\_val] Startwert für die Anzahl X der zu zeichnenden Objekte
\item[max\_val] Endwert für X
\item[step] Schrittweite, um die X nach jeder Messung erhöht wird
\end{description}

\section{Beschreibung der Tests}
\label{sec:tests}

\begin{center}
    \begin{tabular}{ | l | p{12cm} |}
    \hline
    Testname & Beschreibung \\ \hline
    standard & Bunnies werden in die linke obere Ecke gezeichnet.\\ \hline
    random & Bunnies werden in jedem Frame an eine neue zufällige Stelle gezeichnet.\\ \hline
    scaled & Bunnies werden an zufällige feste Position gezeichnet. Mit jedem Frame wird die Skalierung um ein "Wachstum" verändert \(initial 0.1\). Immer wenn die Skalierung >= 5 oder <= 0.2 ist, wird das Wachstum mit -1 multipliziert. \\ \hline
    multitexture & Bunnies werden an zufällige feste Position gezeichnet. Jeder Bunny hat eine feste Textur, die zufällig aus drei Texturen ausgewählt wird.\\ \hline
    texturechange & Bunnies werden an zufällige feste Position gezeichnet. Mit jedem Frame bekommt jeder Bunny eine zufällig aus drei Texturen ausgewählte neue Textur. \\ \hline
    animation & Bunnies werden in die linke obere Ecke gezeichnet und mit zufälligen Geschwindigkeiten in x- und y-Richtung initialisiert. Mit jedem Frame wird die Position des Bunnies um die Geschwindigkeit verschoben. Zusätzlich wird zur y-Geschwindigkeit mit jedem Frame ein Gravitationswert in Richtung (0,-1) addiert. Verlässt der Bunny dadurch den Bildbereich nach links oder rechts, wird die x-Geschwindigkeit mit -1 multipliziert. Verlässt er den Bildbereich nach unten, wird die y-Geschwindigkeit mit -0.8 multipliziert und zusätzlich mit 50-prozentiger Wahrscheinlichkeit ein zufälliger Wert zwischen 3 und 7 addiert. Verlässt er den Bildbereich nach oben, wird die y-Geschwindigkeit auf 0 gesetzt. Dadurch entsteht der Eindruck einer Sprungbewegung.\\ \hline
    \\ \hline
    \end{tabular}
\end{center}

\chapter{Zusammenfassung und Ausblick}
TODO
